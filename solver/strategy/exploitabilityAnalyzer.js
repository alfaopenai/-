(function (global) {
    const root = typeof global !== "undefined" ? global : globalThis;
    const namespace = root.AlphaPoker || (root.AlphaPoker = Object.create(null));
    const registry = namespace.Solvers && typeof namespace.Solvers.register === "function" ? namespace.Solvers : null;

    function clampProbability(value) {
        if (!Number.isFinite(value)) {
            return 0;
        }
        return Math.max(0, Math.min(1, value));
    }

    function computeCallUtility(equity, potSize, betSize) {
        const eq = clampProbability(equity);
        if (betSize <= 0) {
            return eq * potSize;
        }
        return eq * (potSize + 2 * betSize) - betSize;
    }

    function createGameNode(nodeType, options = {}) {
        return {
            type: nodeType,
            actions: options.actions || [],
            utilities: options.utilities || {},
            children: new Map(),
            infoSet: options.infoSet || null,
            player: options.player || 0,
            terminal: nodeType === 'terminal',
            ...options
        };
    }

    function buildGameTree(context) {
        const potSize = Math.max(0, Number(context.potSize) || 0);
        const betSize = Math.max(0, Number(context.betSize) || 0);
        const combos = context.villainRange.combos;

        const root = createGameNode('action', {
            actions: ['bet', 'check'],
            player: 0,
            infoSet: 'hero_root'
        });

        combos.forEach((combo, comboIndex) => {
            const equity = clampProbability(Number(combo.heroEquity) || 0.5);
            const weight = Number(combo.weight) || 0;

            if (weight <= 0) return;

            const infoSetKey = `villain_${Math.floor(equity * 10)}`;

            root.children.set(`bet_${comboIndex}`, createGameNode('action', {
                actions: ['fold', 'call'],
                player: 1,
                infoSet: `${infoSetKey}_vs_bet`,
                children: new Map([
                    ['fold', createGameNode('terminal', {
                        utilities: { 0: potSize, 1: -potSize }
                    })],
                    ['call', createGameNode('terminal', {
                        utilities: {
                            0: computeCallUtility(equity, potSize, betSize),
                            1: -computeCallUtility(equity, potSize, betSize)
                        }
                    })]
                ])
            }));

            root.children.set(`check_${comboIndex}`, createGameNode('action', {
                actions: ['check', 'bet'],
                player: 1,
                infoSet: `${infoSetKey}_vs_check`,
                children: new Map([
                    ['check', createGameNode('terminal', {
                        utilities: {
                            0: equity * potSize,
                            1: -equity * potSize
                        }
                    })],
                    ['bet', createGameNode('action', {
                        actions: ['fold', 'call'],
                        player: 0,
                        infoSet: 'hero_vs_donk',
                        children: new Map([
                            ['fold', createGameNode('terminal', {
                                utilities: { 0: 0, 1: 0 }
                            })],
                            ['call', createGameNode('terminal', {
                                utilities: {
                                    0: computeCallUtility(equity, potSize, betSize),
                                    1: -computeCallUtility(equity, potSize, betSize)
                                }
                            })]
                        ])
                    })]
                ])
            }));
        });

        return root;
    }

    function bestResponseTraversal(node, strategy, player, reachProbs = [1, 1]) {
        if (node.terminal) {
            return node.utilities[player] || 0;
        }

        if (node.player === player) {
            let bestValue = -Infinity;
            let bestAction = null;

            for (const action of node.actions) {
                const child = node.children.get(action);
                if (!child) continue;

                const childValue = bestResponseTraversal(child, strategy, player, reachProbs);
                if (childValue > bestValue) {
                    bestValue = childValue;
                    bestAction = action;
                }
            }

            return bestValue;
        } else {
            const opponentStrategy = strategy.get(node.infoSet) ||
                node.actions.reduce((acc, action, i) => {
                    acc[action] = 1 / node.actions.length;
                    return acc;
                }, {});

            let expectedValue = 0;
            for (const action of node.actions) {
                const child = node.children.get(action);
                if (!child) continue;

                const actionProb = opponentStrategy[action] || 0;
                const newReachProbs = [...reachProbs];
                newReachProbs[node.player] *= actionProb;

                const childValue = bestResponseTraversal(child, strategy, player, newReachProbs);
                expectedValue += actionProb * childValue;
            }

            return expectedValue;
        }
    }

    function computeStrategyProfile(context, existingStrategy) {
        const combos = context.villainRange.combos;
        const totalWeight = context.villainRange.totalWeight || 1;
        const strategyMap = new Map();

        if (existingStrategy) {
            strategyMap.set('hero_root', {
                bet: existingStrategy.heroStrategy?.bet || 0.5,
                check: existingStrategy.heroStrategy?.check || 0.5
            });

            strategyMap.set('hero_vs_donk', {
                fold: existingStrategy.heroCallStrategy?.fold || 0.5,
                call: existingStrategy.heroCallStrategy?.call || 0.5
            });

            combos.forEach((combo, index) => {
                const equity = clampProbability(Number(combo.heroEquity) || 0.5);
                const bucketIndex = Math.floor(equity * 10);
                const infoSetBet = `villain_${bucketIndex}_vs_bet`;
                const infoSetCheck = `villain_${bucketIndex}_vs_check`;

                const callProb = existingStrategy.callProbabilities?.[index] ||
                    existingStrategy.villainCallFrequency || 0.5;
                const betAfterCheckProb = existingStrategy.betAfterCheckProbabilities?.[index] ||
                    existingStrategy.villainBetAfterCheckFrequency || 0.3;

                strategyMap.set(infoSetBet, {
                    fold: 1 - callProb,
                    call: callProb
                });

                strategyMap.set(infoSetCheck, {
                    check: 1 - betAfterCheckProb,
                    bet: betAfterCheckProb
                });
            });
        } else {
            strategyMap.set('hero_root', { bet: 0.5, check: 0.5 });
            strategyMap.set('hero_vs_donk', { fold: 0.5, call: 0.5 });

            combos.forEach((combo, index) => {
                const equity = clampProbability(Number(combo.heroEquity) || 0.5);
                const bucketIndex = Math.floor(equity * 10);

                strategyMap.set(`villain_${bucketIndex}_vs_bet`, { fold: 0.5, call: 0.5 });
                strategyMap.set(`villain_${bucketIndex}_vs_check`, { check: 0.7, bet: 0.3 });
            });
        }

        return strategyMap;
    }

    function calculateExploitability(context, strategy = null) {
        const gameTree = buildGameTree(context);
        const strategyProfile = computeStrategyProfile(context, strategy);
        const combos = context.villainRange.combos;
        const totalWeight = context.villainRange.totalWeight || 1;

        let player0BestResponse = 0;
        let player1BestResponse = 0;
        let strategyUtility0 = 0;
        let strategyUtility1 = 0;

        combos.forEach((combo, index) => {
            const weight = Number(combo.weight) || 0;
            if (weight <= 0) return;

            const weightShare = weight / totalWeight;

            const br0 = bestResponseTraversal(gameTree, strategyProfile, 0);
            const br1 = bestResponseTraversal(gameTree, strategyProfile, 1);

            player0BestResponse += weightShare * br0;
            player1BestResponse += weightShare * br1;

            const stratUtil0 = computeStrategyUtility(gameTree, strategyProfile, 0);
            const stratUtil1 = computeStrategyUtility(gameTree, strategyProfile, 1);

            strategyUtility0 += weightShare * stratUtil0;
            strategyUtility1 += weightShare * stratUtil1;
        });

        const exploitability0 = player0BestResponse - strategyUtility0;
        const exploitability1 = player1BestResponse - strategyUtility1;
        const totalExploitability = (exploitability0 + exploitability1) / 2;

        return {
            total: Math.max(0, totalExploitability),
            player0: Math.max(0, exploitability0),
            player1: Math.max(0, exploitability1),
            bestResponseUtility: {
                player0: player0BestResponse,
                player1: player1BestResponse
            },
            strategyUtility: {
                player0: strategyUtility0,
                player1: strategyUtility1
            },
            breakdown: {
                heroExploitability: Math.max(0, exploitability0),
                villainExploitability: Math.max(0, exploitability1)
            }
        };
    }

    function computeStrategyUtility(node, strategy, player, reachProbs = [1, 1]) {
        if (node.terminal) {
            return (node.utilities[player] || 0) * reachProbs[0] * reachProbs[1];
        }

        const currentStrategy = strategy.get(node.infoSet) ||
            node.actions.reduce((acc, action) => {
                acc[action] = 1 / node.actions.length;
                return acc;
            }, {});

        let expectedValue = 0;

        for (const action of node.actions) {
            const child = node.children.get(action);
            if (!child) continue;

            const actionProb = currentStrategy[action] || 0;
            const newReachProbs = [...reachProbs];
            newReachProbs[node.player] *= actionProb;

            const childValue = computeStrategyUtility(child, strategy, player, newReachProbs);
            expectedValue += childValue;
        }

        return expectedValue;
    }

    function analyzeStrategy(context, strategy) {
        const exploitability = calculateExploitability(context, strategy);
        const gameTree = buildGameTree(context);
        const strategyProfile = computeStrategyProfile(context, strategy);

        const infoSetAnalysis = [];
        const combos = context.villainRange.combos;

        strategyProfile.forEach((strategyVector, infoSet) => {
            const entropy = computeEntropy(Object.values(strategyVector));
            const uniformity = computeUniformity(Object.values(strategyVector));

            infoSetAnalysis.push({
                infoSet,
                strategy: strategyVector,
                entropy,
                uniformity,
                actionCount: Object.keys(strategyVector).length
            });
        });

        const convergenceMetrics = {
            totalExploitability: exploitability.total,
            relativeDivergence: computeKLDivergence(strategy),
            regretMagnitude: estimateRegretMagnitude(strategy),
            strategyStability: computeStrategyStability(strategy)
        };

        const qualityMetrics = {
            nashDistance: exploitability.total,
            balancedness: computeBalancedness(strategy),
            complexity: infoSetAnalysis.reduce((sum, info) => sum + info.entropy, 0) / infoSetAnalysis.length,
            consistency: computeConsistency(strategy, context)
        };

        return {
            exploitability,
            convergenceMetrics,
            qualityMetrics,
            infoSetAnalysis: infoSetAnalysis.slice(0, 20),
            recommendations: generateRecommendations(exploitability, qualityMetrics),
            metadata: {
                gameTreeSize: countNodes(gameTree),
                infoSetCount: strategyProfile.size,
                totalCombinations: combos.length
            }
        };
    }

    function computeEntropy(probabilities) {
        let entropy = 0;
        for (const prob of probabilities) {
            if (prob > 1e-12) {
                entropy -= prob * Math.log2(prob);
            }
        }
        return entropy;
    }

    function computeUniformity(probabilities) {
        const uniform = 1 / probabilities.length;
        let divergence = 0;

        for (const prob of probabilities) {
            divergence += Math.abs(prob - uniform);
        }

        return 1 - (divergence / 2);
    }

    function computeKLDivergence(strategy) {
        if (!strategy?.heroStrategy) return 0;

        const heroProbs = [strategy.heroStrategy.bet, strategy.heroStrategy.check];
        const uniform = [0.5, 0.5];

        let kl = 0;
        for (let i = 0; i < heroProbs.length; i++) {
            if (heroProbs[i] > 1e-12 && uniform[i] > 1e-12) {
                kl += heroProbs[i] * Math.log(heroProbs[i] / uniform[i]);
            }
        }

        return kl;
    }

    function estimateRegretMagnitude(strategy) {
        return (strategy?.avgRootRegret || 0) + (strategy?.avgCallRegret || 0);
    }

    function computeStrategyStability(strategy) {
        if (!strategy?.heroStrategy) return 0;

        const probs = Object.values(strategy.heroStrategy);
        const variance = probs.reduce((sum, p) => sum + Math.pow(p - 0.5, 2), 0) / probs.length;

        return Math.max(0, 1 - variance * 4);
    }

    function computeBalancedness(strategy) {
        if (!strategy?.heroStrategy) return 0.5;

        const betFreq = strategy.heroStrategy.bet || 0;
        const checkFreq = strategy.heroStrategy.check || 0;
        const ratio = Math.min(betFreq, checkFreq) / Math.max(betFreq, checkFreq, 1e-12);

        return ratio;
    }

    function computeConsistency(strategy, context) {
        const potSize = Number(context.potSize) || 0;
        const betSize = Number(context.betSize) || 0;

        if (potSize <= 0 || betSize <= 0) return 0.5;

        const betSizeRatio = betSize / potSize;
        const expectedBetFreq = Math.min(0.8, Math.max(0.2, 1 - betSizeRatio));
        const actualBetFreq = strategy?.heroStrategy?.bet || 0.5;

        return 1 - Math.abs(expectedBetFreq - actualBetFreq);
    }

    function countNodes(node, visited = new Set()) {
        if (visited.has(node)) return 0;
        visited.add(node);

        let count = 1;
        for (const child of node.children.values()) {
            count += countNodes(child, visited);
        }

        return count;
    }

    function generateRecommendations(exploitability, qualityMetrics) {
        const recommendations = [];

        if (exploitability.total > 0.05) {
            recommendations.push({
                type: 'convergence',
                priority: 'high',
                message: 'Strategy has high exploitability. Consider increasing iterations or using CFR+ for faster convergence.',
                actionable: 'Increase iterations to 50,000+ or switch to enhanced CFR+'
            });
        }

        if (qualityMetrics.balancedness < 0.3) {
            recommendations.push({
                type: 'balance',
                priority: 'medium',
                message: 'Strategy appears unbalanced. Check bet sizing and range construction.',
                actionable: 'Review bet sizing relative to pot size and ensure proper range balance'
            });
        }

        if (qualityMetrics.complexity < 0.5) {
            recommendations.push({
                type: 'complexity',
                priority: 'low',
                message: 'Strategy lacks complexity. Consider adding more bet sizes or improving abstractions.',
                actionable: 'Add multiple bet sizes or improve bucketing strategy'
            });
        }

        if (exploitability.player0 > exploitability.player1 * 2) {
            recommendations.push({
                type: 'bias',
                priority: 'medium',
                message: 'Hero strategy appears more exploitable than villain. Check implementation.',
                actionable: 'Review hero strategy computation and regret updates'
            });
        }

        return recommendations;
    }

    const solverApi = {
        calculateExploitability,
        analyzeStrategy,
        buildGameTree,
        computeStrategyProfile
    };

    if (registry) {
        registry.register({
            id: "exploitabilityAnalyzer",
            label: "Exploitability Analyzer",
            description: "Comprehensive strategy analysis tool for measuring exploitability, convergence quality, and providing actionable recommendations for solver improvement.",
            priority: 15,
            version: "1.0.0",
            origin: "AlphaPoker Strategy Analysis Suite",
            solve(context) {
                if (!context?.villainRange?.combos?.length) {
                    return { ok: false, diagnostics: { reason: "exploitabilityAnalyzer: invalid context" } };
                }

                const baselineExploitability = calculateExploitability(context, null);

                return {
                    ok: true,
                    summary: null,
                    detail: {
                        baselineExploitability,
                        gameComplexity: context.villainRange.combos.length,
                        analysis: 'Use analyzeStrategy() with a solved strategy for full analysis'
                    },
                    diagnostics: {
                        baselineExploitability: baselineExploitability.total,
                        gameSize: context.villainRange.combos.length,
                        potSize: context.potSize,
                        betSize: context.betSize
                    }
                };
            },
            exports: solverApi
        });
    }

    namespace.ExploitabilityAnalyzer = solverApi;
})(typeof window !== "undefined" ? window : globalThis);